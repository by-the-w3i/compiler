Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Unused terminals:

    WHITESPACE
    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statements statement
Rule 3     statements -> <empty>
Rule 4     statement -> expr ;
Rule 5     statement -> declaration ;
Rule 6     statement -> block
Rule 7     statement -> if_block
Rule 8     statement -> while_loop
Rule 9     statement -> break ;
Rule 10    statement -> ;
Rule 11    block -> OPEN_BLOCK statements CLOSE_BLOCK
Rule 12    if_block -> COMMAND_IF ( expr ) statement
Rule 13    if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement
Rule 14    break -> COMMAND_BREAK
Rule 15    while_loop -> COMMAND_WHILE ( expr ) statement
Rule 16    declaration -> TYPE ID
Rule 17    declaration -> TYPE ID = expr
Rule 18    expr -> expr + expr
Rule 19    expr -> expr - expr
Rule 20    expr -> expr * expr
Rule 21    expr -> expr / expr
Rule 22    expr -> expr ASSIGN_ADD expr
Rule 23    expr -> expr ASSIGN_SUB expr
Rule 24    expr -> expr ASSIGN_MULT expr
Rule 25    expr -> expr ASSIGN_DIV expr
Rule 26    expr -> ( expr )
Rule 27    expr -> expr COMP_EQU expr
Rule 28    expr -> expr COMP_NEQU expr
Rule 29    expr -> expr < expr
Rule 30    expr -> expr COMP_LTE expr
Rule 31    expr -> expr > expr
Rule 32    expr -> expr COMP_GTE expr
Rule 33    expr -> expr BOOL_AND expr
Rule 34    expr -> expr BOOL_OR expr
Rule 35    expr -> ! expr
Rule 36    expr -> COMMAND_PRINT ( arguments )
Rule 37    arguments -> expr
Rule 38    arguments -> arguments , expr
Rule 39    expr -> COMMAND_RANDOM ( expr )
Rule 40    expr -> VAL_LITERAL
Rule 41    expr -> - VAL_LITERAL
Rule 42    expr -> CHAR_LITERAL
Rule 43    expr -> variable
Rule 44    expr -> - variable
Rule 45    expr -> variable = expr
Rule 46    variable -> ID

Terminals, with rules where they appear

!                    : 35
(                    : 12 13 15 26 36 39
)                    : 12 13 15 26 36 39
*                    : 20
+                    : 18
,                    : 38
-                    : 19 41 44
/                    : 21
;                    : 4 5 9 10
<                    : 29
=                    : 17 45
>                    : 31
ASSIGN_ADD           : 22
ASSIGN_DIV           : 25
ASSIGN_MULT          : 24
ASSIGN_SUB           : 23
BOOL_AND             : 33
BOOL_OR              : 34
CHAR_LITERAL         : 42
CLOSE_BLOCK          : 11
COMMAND_BREAK        : 14
COMMAND_ELSE         : 13
COMMAND_IF           : 12 13
COMMAND_PRINT        : 36
COMMAND_RANDOM       : 39
COMMAND_WHILE        : 15
COMMENT              : 
COMP_EQU             : 27
COMP_GTE             : 32
COMP_LTE             : 30
COMP_NEQU            : 28
ID                   : 16 17 46
OPEN_BLOCK           : 11
TYPE                 : 16 17
VAL_LITERAL          : 40 41
WHITESPACE           : 
error                : 

Nonterminals, with rules where they appear

arguments            : 36 38
block                : 6
break                : 9
declaration          : 5
expr                 : 4 12 13 15 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 37 38 39 45
if_block             : 7
program              : 0
statement            : 2 12 13 13 15
statements           : 1 2 11
variable             : 43 44 45
while_loop           : 8

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statements statement
    (3) statements -> .

    ;               reduce using rule 3 (statements -> .)
    (               reduce using rule 3 (statements -> .)
    !               reduce using rule 3 (statements -> .)
    COMMAND_PRINT   reduce using rule 3 (statements -> .)
    COMMAND_RANDOM  reduce using rule 3 (statements -> .)
    VAL_LITERAL     reduce using rule 3 (statements -> .)
    -               reduce using rule 3 (statements -> .)
    CHAR_LITERAL    reduce using rule 3 (statements -> .)
    TYPE            reduce using rule 3 (statements -> .)
    OPEN_BLOCK      reduce using rule 3 (statements -> .)
    COMMAND_IF      reduce using rule 3 (statements -> .)
    COMMAND_WHILE   reduce using rule 3 (statements -> .)
    COMMAND_BREAK   reduce using rule 3 (statements -> .)
    ID              reduce using rule 3 (statements -> .)
    $end            reduce using rule 3 (statements -> .)

    statements                     shift and go to state 1
    program                        shift and go to state 2

state 1

    (1) program -> statements .
    (2) statements -> statements . statement
    (4) statement -> . expr ;
    (5) statement -> . declaration ;
    (6) statement -> . block
    (7) statement -> . if_block
    (8) statement -> . while_loop
    (9) statement -> . break ;
    (10) statement -> . ;
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (16) declaration -> . TYPE ID
    (17) declaration -> . TYPE ID = expr
    (11) block -> . OPEN_BLOCK statements CLOSE_BLOCK
    (12) if_block -> . COMMAND_IF ( expr ) statement
    (13) if_block -> . COMMAND_IF ( expr ) statement COMMAND_ELSE statement
    (15) while_loop -> . COMMAND_WHILE ( expr ) statement
    (14) break -> . COMMAND_BREAK
    (46) variable -> . ID

    $end            reduce using rule 1 (program -> statements .)
    ;               shift and go to state 7
    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    TYPE            shift and go to state 5
    OPEN_BLOCK      shift and go to state 15
    COMMAND_IF      shift and go to state 12
    COMMAND_WHILE   shift and go to state 22
    COMMAND_BREAK   shift and go to state 3
    ID              shift and go to state 6

    break                          shift and go to state 9
    block                          shift and go to state 4
    while_loop                     shift and go to state 23
    declaration                    shift and go to state 18
    if_block                       shift and go to state 13
    variable                       shift and go to state 11
    expr                           shift and go to state 8
    statement                      shift and go to state 16

state 2

    (0) S' -> program .



state 3

    (14) break -> COMMAND_BREAK .

    ;               reduce using rule 14 (break -> COMMAND_BREAK .)


state 4

    (6) statement -> block .

    COMMAND_ELSE    reduce using rule 6 (statement -> block .)
    ;               reduce using rule 6 (statement -> block .)
    (               reduce using rule 6 (statement -> block .)
    !               reduce using rule 6 (statement -> block .)
    COMMAND_PRINT   reduce using rule 6 (statement -> block .)
    COMMAND_RANDOM  reduce using rule 6 (statement -> block .)
    VAL_LITERAL     reduce using rule 6 (statement -> block .)
    -               reduce using rule 6 (statement -> block .)
    CHAR_LITERAL    reduce using rule 6 (statement -> block .)
    TYPE            reduce using rule 6 (statement -> block .)
    OPEN_BLOCK      reduce using rule 6 (statement -> block .)
    COMMAND_IF      reduce using rule 6 (statement -> block .)
    COMMAND_WHILE   reduce using rule 6 (statement -> block .)
    COMMAND_BREAK   reduce using rule 6 (statement -> block .)
    ID              reduce using rule 6 (statement -> block .)
    $end            reduce using rule 6 (statement -> block .)
    CLOSE_BLOCK     reduce using rule 6 (statement -> block .)


state 5

    (16) declaration -> TYPE . ID
    (17) declaration -> TYPE . ID = expr

    ID              shift and go to state 25


state 6

    (46) variable -> ID .

    =               reduce using rule 46 (variable -> ID .)
    +               reduce using rule 46 (variable -> ID .)
    -               reduce using rule 46 (variable -> ID .)
    *               reduce using rule 46 (variable -> ID .)
    /               reduce using rule 46 (variable -> ID .)
    ASSIGN_ADD      reduce using rule 46 (variable -> ID .)
    ASSIGN_SUB      reduce using rule 46 (variable -> ID .)
    ASSIGN_MULT     reduce using rule 46 (variable -> ID .)
    ASSIGN_DIV      reduce using rule 46 (variable -> ID .)
    COMP_EQU        reduce using rule 46 (variable -> ID .)
    COMP_NEQU       reduce using rule 46 (variable -> ID .)
    <               reduce using rule 46 (variable -> ID .)
    COMP_LTE        reduce using rule 46 (variable -> ID .)
    >               reduce using rule 46 (variable -> ID .)
    COMP_GTE        reduce using rule 46 (variable -> ID .)
    BOOL_AND        reduce using rule 46 (variable -> ID .)
    BOOL_OR         reduce using rule 46 (variable -> ID .)
    ;               reduce using rule 46 (variable -> ID .)
    )               reduce using rule 46 (variable -> ID .)
    ,               reduce using rule 46 (variable -> ID .)


state 7

    (10) statement -> ; .

    COMMAND_ELSE    reduce using rule 10 (statement -> ; .)
    ;               reduce using rule 10 (statement -> ; .)
    (               reduce using rule 10 (statement -> ; .)
    !               reduce using rule 10 (statement -> ; .)
    COMMAND_PRINT   reduce using rule 10 (statement -> ; .)
    COMMAND_RANDOM  reduce using rule 10 (statement -> ; .)
    VAL_LITERAL     reduce using rule 10 (statement -> ; .)
    -               reduce using rule 10 (statement -> ; .)
    CHAR_LITERAL    reduce using rule 10 (statement -> ; .)
    TYPE            reduce using rule 10 (statement -> ; .)
    OPEN_BLOCK      reduce using rule 10 (statement -> ; .)
    COMMAND_IF      reduce using rule 10 (statement -> ; .)
    COMMAND_WHILE   reduce using rule 10 (statement -> ; .)
    COMMAND_BREAK   reduce using rule 10 (statement -> ; .)
    ID              reduce using rule 10 (statement -> ; .)
    $end            reduce using rule 10 (statement -> ; .)
    CLOSE_BLOCK     reduce using rule 10 (statement -> ; .)


state 8

    (4) statement -> expr . ;
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    ;               shift and go to state 31
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    ASSIGN_ADD      shift and go to state 40
    ASSIGN_SUB      shift and go to state 39
    ASSIGN_MULT     shift and go to state 37
    ASSIGN_DIV      shift and go to state 26
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32


state 9

    (9) statement -> break . ;

    ;               shift and go to state 43


state 10

    (36) expr -> COMMAND_PRINT . ( arguments )

    (               shift and go to state 44


state 11

    (43) expr -> variable .
    (45) expr -> variable . = expr

    +               reduce using rule 43 (expr -> variable .)
    -               reduce using rule 43 (expr -> variable .)
    *               reduce using rule 43 (expr -> variable .)
    /               reduce using rule 43 (expr -> variable .)
    ASSIGN_ADD      reduce using rule 43 (expr -> variable .)
    ASSIGN_SUB      reduce using rule 43 (expr -> variable .)
    ASSIGN_MULT     reduce using rule 43 (expr -> variable .)
    ASSIGN_DIV      reduce using rule 43 (expr -> variable .)
    COMP_EQU        reduce using rule 43 (expr -> variable .)
    COMP_NEQU       reduce using rule 43 (expr -> variable .)
    <               reduce using rule 43 (expr -> variable .)
    COMP_LTE        reduce using rule 43 (expr -> variable .)
    >               reduce using rule 43 (expr -> variable .)
    COMP_GTE        reduce using rule 43 (expr -> variable .)
    BOOL_AND        reduce using rule 43 (expr -> variable .)
    BOOL_OR         reduce using rule 43 (expr -> variable .)
    ;               reduce using rule 43 (expr -> variable .)
    )               reduce using rule 43 (expr -> variable .)
    ,               reduce using rule 43 (expr -> variable .)
    =               shift and go to state 45


state 12

    (12) if_block -> COMMAND_IF . ( expr ) statement
    (13) if_block -> COMMAND_IF . ( expr ) statement COMMAND_ELSE statement

    (               shift and go to state 46


state 13

    (7) statement -> if_block .

    COMMAND_ELSE    reduce using rule 7 (statement -> if_block .)
    ;               reduce using rule 7 (statement -> if_block .)
    (               reduce using rule 7 (statement -> if_block .)
    !               reduce using rule 7 (statement -> if_block .)
    COMMAND_PRINT   reduce using rule 7 (statement -> if_block .)
    COMMAND_RANDOM  reduce using rule 7 (statement -> if_block .)
    VAL_LITERAL     reduce using rule 7 (statement -> if_block .)
    -               reduce using rule 7 (statement -> if_block .)
    CHAR_LITERAL    reduce using rule 7 (statement -> if_block .)
    TYPE            reduce using rule 7 (statement -> if_block .)
    OPEN_BLOCK      reduce using rule 7 (statement -> if_block .)
    COMMAND_IF      reduce using rule 7 (statement -> if_block .)
    COMMAND_WHILE   reduce using rule 7 (statement -> if_block .)
    COMMAND_BREAK   reduce using rule 7 (statement -> if_block .)
    ID              reduce using rule 7 (statement -> if_block .)
    $end            reduce using rule 7 (statement -> if_block .)
    CLOSE_BLOCK     reduce using rule 7 (statement -> if_block .)


state 14

    (41) expr -> - . VAL_LITERAL
    (44) expr -> - . variable
    (46) variable -> . ID

    VAL_LITERAL     shift and go to state 48
    ID              shift and go to state 6

    variable                       shift and go to state 47

state 15

    (11) block -> OPEN_BLOCK . statements CLOSE_BLOCK
    (2) statements -> . statements statement
    (3) statements -> .

    CLOSE_BLOCK     reduce using rule 3 (statements -> .)
    ;               reduce using rule 3 (statements -> .)
    (               reduce using rule 3 (statements -> .)
    !               reduce using rule 3 (statements -> .)
    COMMAND_PRINT   reduce using rule 3 (statements -> .)
    COMMAND_RANDOM  reduce using rule 3 (statements -> .)
    VAL_LITERAL     reduce using rule 3 (statements -> .)
    -               reduce using rule 3 (statements -> .)
    CHAR_LITERAL    reduce using rule 3 (statements -> .)
    TYPE            reduce using rule 3 (statements -> .)
    OPEN_BLOCK      reduce using rule 3 (statements -> .)
    COMMAND_IF      reduce using rule 3 (statements -> .)
    COMMAND_WHILE   reduce using rule 3 (statements -> .)
    COMMAND_BREAK   reduce using rule 3 (statements -> .)
    ID              reduce using rule 3 (statements -> .)

    statements                     shift and go to state 49

state 16

    (2) statements -> statements statement .

    ;               reduce using rule 2 (statements -> statements statement .)
    (               reduce using rule 2 (statements -> statements statement .)
    !               reduce using rule 2 (statements -> statements statement .)
    COMMAND_PRINT   reduce using rule 2 (statements -> statements statement .)
    COMMAND_RANDOM  reduce using rule 2 (statements -> statements statement .)
    VAL_LITERAL     reduce using rule 2 (statements -> statements statement .)
    -               reduce using rule 2 (statements -> statements statement .)
    CHAR_LITERAL    reduce using rule 2 (statements -> statements statement .)
    TYPE            reduce using rule 2 (statements -> statements statement .)
    OPEN_BLOCK      reduce using rule 2 (statements -> statements statement .)
    COMMAND_IF      reduce using rule 2 (statements -> statements statement .)
    COMMAND_WHILE   reduce using rule 2 (statements -> statements statement .)
    COMMAND_BREAK   reduce using rule 2 (statements -> statements statement .)
    ID              reduce using rule 2 (statements -> statements statement .)
    $end            reduce using rule 2 (statements -> statements statement .)
    CLOSE_BLOCK     reduce using rule 2 (statements -> statements statement .)


state 17

    (39) expr -> COMMAND_RANDOM . ( expr )

    (               shift and go to state 50


state 18

    (5) statement -> declaration . ;

    ;               shift and go to state 51


state 19

    (35) expr -> ! . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 52

state 20

    (26) expr -> ( . expr )
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 53

state 21

    (40) expr -> VAL_LITERAL .

    +               reduce using rule 40 (expr -> VAL_LITERAL .)
    -               reduce using rule 40 (expr -> VAL_LITERAL .)
    *               reduce using rule 40 (expr -> VAL_LITERAL .)
    /               reduce using rule 40 (expr -> VAL_LITERAL .)
    ASSIGN_ADD      reduce using rule 40 (expr -> VAL_LITERAL .)
    ASSIGN_SUB      reduce using rule 40 (expr -> VAL_LITERAL .)
    ASSIGN_MULT     reduce using rule 40 (expr -> VAL_LITERAL .)
    ASSIGN_DIV      reduce using rule 40 (expr -> VAL_LITERAL .)
    COMP_EQU        reduce using rule 40 (expr -> VAL_LITERAL .)
    COMP_NEQU       reduce using rule 40 (expr -> VAL_LITERAL .)
    <               reduce using rule 40 (expr -> VAL_LITERAL .)
    COMP_LTE        reduce using rule 40 (expr -> VAL_LITERAL .)
    >               reduce using rule 40 (expr -> VAL_LITERAL .)
    COMP_GTE        reduce using rule 40 (expr -> VAL_LITERAL .)
    BOOL_AND        reduce using rule 40 (expr -> VAL_LITERAL .)
    BOOL_OR         reduce using rule 40 (expr -> VAL_LITERAL .)
    ;               reduce using rule 40 (expr -> VAL_LITERAL .)
    )               reduce using rule 40 (expr -> VAL_LITERAL .)
    ,               reduce using rule 40 (expr -> VAL_LITERAL .)


state 22

    (15) while_loop -> COMMAND_WHILE . ( expr ) statement

    (               shift and go to state 54


state 23

    (8) statement -> while_loop .

    COMMAND_ELSE    reduce using rule 8 (statement -> while_loop .)
    ;               reduce using rule 8 (statement -> while_loop .)
    (               reduce using rule 8 (statement -> while_loop .)
    !               reduce using rule 8 (statement -> while_loop .)
    COMMAND_PRINT   reduce using rule 8 (statement -> while_loop .)
    COMMAND_RANDOM  reduce using rule 8 (statement -> while_loop .)
    VAL_LITERAL     reduce using rule 8 (statement -> while_loop .)
    -               reduce using rule 8 (statement -> while_loop .)
    CHAR_LITERAL    reduce using rule 8 (statement -> while_loop .)
    TYPE            reduce using rule 8 (statement -> while_loop .)
    OPEN_BLOCK      reduce using rule 8 (statement -> while_loop .)
    COMMAND_IF      reduce using rule 8 (statement -> while_loop .)
    COMMAND_WHILE   reduce using rule 8 (statement -> while_loop .)
    COMMAND_BREAK   reduce using rule 8 (statement -> while_loop .)
    ID              reduce using rule 8 (statement -> while_loop .)
    $end            reduce using rule 8 (statement -> while_loop .)
    CLOSE_BLOCK     reduce using rule 8 (statement -> while_loop .)


state 24

    (42) expr -> CHAR_LITERAL .

    +               reduce using rule 42 (expr -> CHAR_LITERAL .)
    -               reduce using rule 42 (expr -> CHAR_LITERAL .)
    *               reduce using rule 42 (expr -> CHAR_LITERAL .)
    /               reduce using rule 42 (expr -> CHAR_LITERAL .)
    ASSIGN_ADD      reduce using rule 42 (expr -> CHAR_LITERAL .)
    ASSIGN_SUB      reduce using rule 42 (expr -> CHAR_LITERAL .)
    ASSIGN_MULT     reduce using rule 42 (expr -> CHAR_LITERAL .)
    ASSIGN_DIV      reduce using rule 42 (expr -> CHAR_LITERAL .)
    COMP_EQU        reduce using rule 42 (expr -> CHAR_LITERAL .)
    COMP_NEQU       reduce using rule 42 (expr -> CHAR_LITERAL .)
    <               reduce using rule 42 (expr -> CHAR_LITERAL .)
    COMP_LTE        reduce using rule 42 (expr -> CHAR_LITERAL .)
    >               reduce using rule 42 (expr -> CHAR_LITERAL .)
    COMP_GTE        reduce using rule 42 (expr -> CHAR_LITERAL .)
    BOOL_AND        reduce using rule 42 (expr -> CHAR_LITERAL .)
    BOOL_OR         reduce using rule 42 (expr -> CHAR_LITERAL .)
    ;               reduce using rule 42 (expr -> CHAR_LITERAL .)
    )               reduce using rule 42 (expr -> CHAR_LITERAL .)
    ,               reduce using rule 42 (expr -> CHAR_LITERAL .)


state 25

    (16) declaration -> TYPE ID .
    (17) declaration -> TYPE ID . = expr

    ;               reduce using rule 16 (declaration -> TYPE ID .)
    =               shift and go to state 55


state 26

    (25) expr -> expr ASSIGN_DIV . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 56

state 27

    (20) expr -> expr * . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 57

state 28

    (21) expr -> expr / . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 58

state 29

    (33) expr -> expr BOOL_AND . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 59

state 30

    (32) expr -> expr COMP_GTE . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 60

state 31

    (4) statement -> expr ; .

    COMMAND_ELSE    reduce using rule 4 (statement -> expr ; .)
    ;               reduce using rule 4 (statement -> expr ; .)
    (               reduce using rule 4 (statement -> expr ; .)
    !               reduce using rule 4 (statement -> expr ; .)
    COMMAND_PRINT   reduce using rule 4 (statement -> expr ; .)
    COMMAND_RANDOM  reduce using rule 4 (statement -> expr ; .)
    VAL_LITERAL     reduce using rule 4 (statement -> expr ; .)
    -               reduce using rule 4 (statement -> expr ; .)
    CHAR_LITERAL    reduce using rule 4 (statement -> expr ; .)
    TYPE            reduce using rule 4 (statement -> expr ; .)
    OPEN_BLOCK      reduce using rule 4 (statement -> expr ; .)
    COMMAND_IF      reduce using rule 4 (statement -> expr ; .)
    COMMAND_WHILE   reduce using rule 4 (statement -> expr ; .)
    COMMAND_BREAK   reduce using rule 4 (statement -> expr ; .)
    ID              reduce using rule 4 (statement -> expr ; .)
    $end            reduce using rule 4 (statement -> expr ; .)
    CLOSE_BLOCK     reduce using rule 4 (statement -> expr ; .)


state 32

    (34) expr -> expr BOOL_OR . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 61

state 33

    (19) expr -> expr - . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 62

state 34

    (29) expr -> expr < . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 63

state 35

    (30) expr -> expr COMP_LTE . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 64

state 36

    (18) expr -> expr + . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 65

state 37

    (24) expr -> expr ASSIGN_MULT . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 66

state 38

    (31) expr -> expr > . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 67

state 39

    (23) expr -> expr ASSIGN_SUB . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 68

state 40

    (22) expr -> expr ASSIGN_ADD . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 69

state 41

    (28) expr -> expr COMP_NEQU . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 70

state 42

    (27) expr -> expr COMP_EQU . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 71

state 43

    (9) statement -> break ; .

    COMMAND_ELSE    reduce using rule 9 (statement -> break ; .)
    ;               reduce using rule 9 (statement -> break ; .)
    (               reduce using rule 9 (statement -> break ; .)
    !               reduce using rule 9 (statement -> break ; .)
    COMMAND_PRINT   reduce using rule 9 (statement -> break ; .)
    COMMAND_RANDOM  reduce using rule 9 (statement -> break ; .)
    VAL_LITERAL     reduce using rule 9 (statement -> break ; .)
    -               reduce using rule 9 (statement -> break ; .)
    CHAR_LITERAL    reduce using rule 9 (statement -> break ; .)
    TYPE            reduce using rule 9 (statement -> break ; .)
    OPEN_BLOCK      reduce using rule 9 (statement -> break ; .)
    COMMAND_IF      reduce using rule 9 (statement -> break ; .)
    COMMAND_WHILE   reduce using rule 9 (statement -> break ; .)
    COMMAND_BREAK   reduce using rule 9 (statement -> break ; .)
    ID              reduce using rule 9 (statement -> break ; .)
    $end            reduce using rule 9 (statement -> break ; .)
    CLOSE_BLOCK     reduce using rule 9 (statement -> break ; .)


state 44

    (36) expr -> COMMAND_PRINT ( . arguments )
    (37) arguments -> . expr
    (38) arguments -> . arguments , expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 72
    arguments                      shift and go to state 73

state 45

    (45) expr -> variable = . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 74

state 46

    (12) if_block -> COMMAND_IF ( . expr ) statement
    (13) if_block -> COMMAND_IF ( . expr ) statement COMMAND_ELSE statement
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 75

state 47

    (44) expr -> - variable .

    +               reduce using rule 44 (expr -> - variable .)
    -               reduce using rule 44 (expr -> - variable .)
    *               reduce using rule 44 (expr -> - variable .)
    /               reduce using rule 44 (expr -> - variable .)
    ASSIGN_ADD      reduce using rule 44 (expr -> - variable .)
    ASSIGN_SUB      reduce using rule 44 (expr -> - variable .)
    ASSIGN_MULT     reduce using rule 44 (expr -> - variable .)
    ASSIGN_DIV      reduce using rule 44 (expr -> - variable .)
    COMP_EQU        reduce using rule 44 (expr -> - variable .)
    COMP_NEQU       reduce using rule 44 (expr -> - variable .)
    <               reduce using rule 44 (expr -> - variable .)
    COMP_LTE        reduce using rule 44 (expr -> - variable .)
    >               reduce using rule 44 (expr -> - variable .)
    COMP_GTE        reduce using rule 44 (expr -> - variable .)
    BOOL_AND        reduce using rule 44 (expr -> - variable .)
    BOOL_OR         reduce using rule 44 (expr -> - variable .)
    ;               reduce using rule 44 (expr -> - variable .)
    )               reduce using rule 44 (expr -> - variable .)
    ,               reduce using rule 44 (expr -> - variable .)


state 48

    (41) expr -> - VAL_LITERAL .

    +               reduce using rule 41 (expr -> - VAL_LITERAL .)
    -               reduce using rule 41 (expr -> - VAL_LITERAL .)
    *               reduce using rule 41 (expr -> - VAL_LITERAL .)
    /               reduce using rule 41 (expr -> - VAL_LITERAL .)
    ASSIGN_ADD      reduce using rule 41 (expr -> - VAL_LITERAL .)
    ASSIGN_SUB      reduce using rule 41 (expr -> - VAL_LITERAL .)
    ASSIGN_MULT     reduce using rule 41 (expr -> - VAL_LITERAL .)
    ASSIGN_DIV      reduce using rule 41 (expr -> - VAL_LITERAL .)
    COMP_EQU        reduce using rule 41 (expr -> - VAL_LITERAL .)
    COMP_NEQU       reduce using rule 41 (expr -> - VAL_LITERAL .)
    <               reduce using rule 41 (expr -> - VAL_LITERAL .)
    COMP_LTE        reduce using rule 41 (expr -> - VAL_LITERAL .)
    >               reduce using rule 41 (expr -> - VAL_LITERAL .)
    COMP_GTE        reduce using rule 41 (expr -> - VAL_LITERAL .)
    BOOL_AND        reduce using rule 41 (expr -> - VAL_LITERAL .)
    BOOL_OR         reduce using rule 41 (expr -> - VAL_LITERAL .)
    ;               reduce using rule 41 (expr -> - VAL_LITERAL .)
    )               reduce using rule 41 (expr -> - VAL_LITERAL .)
    ,               reduce using rule 41 (expr -> - VAL_LITERAL .)


state 49

    (11) block -> OPEN_BLOCK statements . CLOSE_BLOCK
    (2) statements -> statements . statement
    (4) statement -> . expr ;
    (5) statement -> . declaration ;
    (6) statement -> . block
    (7) statement -> . if_block
    (8) statement -> . while_loop
    (9) statement -> . break ;
    (10) statement -> . ;
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (16) declaration -> . TYPE ID
    (17) declaration -> . TYPE ID = expr
    (11) block -> . OPEN_BLOCK statements CLOSE_BLOCK
    (12) if_block -> . COMMAND_IF ( expr ) statement
    (13) if_block -> . COMMAND_IF ( expr ) statement COMMAND_ELSE statement
    (15) while_loop -> . COMMAND_WHILE ( expr ) statement
    (14) break -> . COMMAND_BREAK
    (46) variable -> . ID

    CLOSE_BLOCK     shift and go to state 76
    ;               shift and go to state 7
    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    TYPE            shift and go to state 5
    OPEN_BLOCK      shift and go to state 15
    COMMAND_IF      shift and go to state 12
    COMMAND_WHILE   shift and go to state 22
    COMMAND_BREAK   shift and go to state 3
    ID              shift and go to state 6

    break                          shift and go to state 9
    block                          shift and go to state 4
    while_loop                     shift and go to state 23
    declaration                    shift and go to state 18
    if_block                       shift and go to state 13
    variable                       shift and go to state 11
    expr                           shift and go to state 8
    statement                      shift and go to state 16

state 50

    (39) expr -> COMMAND_RANDOM ( . expr )
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 77

state 51

    (5) statement -> declaration ; .

    COMMAND_ELSE    reduce using rule 5 (statement -> declaration ; .)
    ;               reduce using rule 5 (statement -> declaration ; .)
    (               reduce using rule 5 (statement -> declaration ; .)
    !               reduce using rule 5 (statement -> declaration ; .)
    COMMAND_PRINT   reduce using rule 5 (statement -> declaration ; .)
    COMMAND_RANDOM  reduce using rule 5 (statement -> declaration ; .)
    VAL_LITERAL     reduce using rule 5 (statement -> declaration ; .)
    -               reduce using rule 5 (statement -> declaration ; .)
    CHAR_LITERAL    reduce using rule 5 (statement -> declaration ; .)
    TYPE            reduce using rule 5 (statement -> declaration ; .)
    OPEN_BLOCK      reduce using rule 5 (statement -> declaration ; .)
    COMMAND_IF      reduce using rule 5 (statement -> declaration ; .)
    COMMAND_WHILE   reduce using rule 5 (statement -> declaration ; .)
    COMMAND_BREAK   reduce using rule 5 (statement -> declaration ; .)
    ID              reduce using rule 5 (statement -> declaration ; .)
    $end            reduce using rule 5 (statement -> declaration ; .)
    CLOSE_BLOCK     reduce using rule 5 (statement -> declaration ; .)


state 52

    (35) expr -> ! expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    +               reduce using rule 35 (expr -> ! expr .)
    -               reduce using rule 35 (expr -> ! expr .)
    *               reduce using rule 35 (expr -> ! expr .)
    /               reduce using rule 35 (expr -> ! expr .)
    ASSIGN_ADD      reduce using rule 35 (expr -> ! expr .)
    ASSIGN_SUB      reduce using rule 35 (expr -> ! expr .)
    ASSIGN_MULT     reduce using rule 35 (expr -> ! expr .)
    ASSIGN_DIV      reduce using rule 35 (expr -> ! expr .)
    COMP_EQU        reduce using rule 35 (expr -> ! expr .)
    COMP_NEQU       reduce using rule 35 (expr -> ! expr .)
    <               reduce using rule 35 (expr -> ! expr .)
    COMP_LTE        reduce using rule 35 (expr -> ! expr .)
    >               reduce using rule 35 (expr -> ! expr .)
    COMP_GTE        reduce using rule 35 (expr -> ! expr .)
    BOOL_AND        reduce using rule 35 (expr -> ! expr .)
    BOOL_OR         reduce using rule 35 (expr -> ! expr .)
    ;               reduce using rule 35 (expr -> ! expr .)
    )               reduce using rule 35 (expr -> ! expr .)
    ,               reduce using rule 35 (expr -> ! expr .)

  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 27 ]
  ! /               [ shift and go to state 28 ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! COMP_EQU        [ shift and go to state 42 ]
  ! COMP_NEQU       [ shift and go to state 41 ]
  ! <               [ shift and go to state 34 ]
  ! COMP_LTE        [ shift and go to state 35 ]
  ! >               [ shift and go to state 38 ]
  ! COMP_GTE        [ shift and go to state 30 ]
  ! BOOL_AND        [ shift and go to state 29 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 53

    (26) expr -> ( expr . )
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    )               shift and go to state 78
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    ASSIGN_ADD      shift and go to state 40
    ASSIGN_SUB      shift and go to state 39
    ASSIGN_MULT     shift and go to state 37
    ASSIGN_DIV      shift and go to state 26
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32


state 54

    (15) while_loop -> COMMAND_WHILE ( . expr ) statement
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 79

state 55

    (17) declaration -> TYPE ID = . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 80

state 56

    (25) expr -> expr ASSIGN_DIV expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ASSIGN_ADD resolved as shift
  ! shift/reduce conflict for ASSIGN_SUB resolved as shift
  ! shift/reduce conflict for ASSIGN_MULT resolved as shift
  ! shift/reduce conflict for ASSIGN_DIV resolved as shift
  ! shift/reduce conflict for COMP_EQU resolved as shift
  ! shift/reduce conflict for COMP_NEQU resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for COMP_LTE resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for COMP_GTE resolved as shift
  ! shift/reduce conflict for BOOL_AND resolved as shift
  ! shift/reduce conflict for BOOL_OR resolved as shift
    ;               reduce using rule 25 (expr -> expr ASSIGN_DIV expr .)
    )               reduce using rule 25 (expr -> expr ASSIGN_DIV expr .)
    ,               reduce using rule 25 (expr -> expr ASSIGN_DIV expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    ASSIGN_ADD      shift and go to state 40
    ASSIGN_SUB      shift and go to state 39
    ASSIGN_MULT     shift and go to state 37
    ASSIGN_DIV      shift and go to state 26
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32

  ! +               [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! -               [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! *               [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! /               [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! ASSIGN_ADD      [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! ASSIGN_SUB      [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! ASSIGN_MULT     [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! ASSIGN_DIV      [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! COMP_EQU        [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! COMP_NEQU       [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! <               [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! COMP_LTE        [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! >               [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! COMP_GTE        [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! BOOL_AND        [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]
  ! BOOL_OR         [ reduce using rule 25 (expr -> expr ASSIGN_DIV expr .) ]


state 57

    (20) expr -> expr * expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    +               reduce using rule 20 (expr -> expr * expr .)
    -               reduce using rule 20 (expr -> expr * expr .)
    *               reduce using rule 20 (expr -> expr * expr .)
    /               reduce using rule 20 (expr -> expr * expr .)
    ASSIGN_ADD      reduce using rule 20 (expr -> expr * expr .)
    ASSIGN_SUB      reduce using rule 20 (expr -> expr * expr .)
    ASSIGN_MULT     reduce using rule 20 (expr -> expr * expr .)
    ASSIGN_DIV      reduce using rule 20 (expr -> expr * expr .)
    COMP_EQU        reduce using rule 20 (expr -> expr * expr .)
    COMP_NEQU       reduce using rule 20 (expr -> expr * expr .)
    <               reduce using rule 20 (expr -> expr * expr .)
    COMP_LTE        reduce using rule 20 (expr -> expr * expr .)
    >               reduce using rule 20 (expr -> expr * expr .)
    COMP_GTE        reduce using rule 20 (expr -> expr * expr .)
    BOOL_AND        reduce using rule 20 (expr -> expr * expr .)
    BOOL_OR         reduce using rule 20 (expr -> expr * expr .)
    ;               reduce using rule 20 (expr -> expr * expr .)
    )               reduce using rule 20 (expr -> expr * expr .)
    ,               reduce using rule 20 (expr -> expr * expr .)

  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 27 ]
  ! /               [ shift and go to state 28 ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! COMP_EQU        [ shift and go to state 42 ]
  ! COMP_NEQU       [ shift and go to state 41 ]
  ! <               [ shift and go to state 34 ]
  ! COMP_LTE        [ shift and go to state 35 ]
  ! >               [ shift and go to state 38 ]
  ! COMP_GTE        [ shift and go to state 30 ]
  ! BOOL_AND        [ shift and go to state 29 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 58

    (21) expr -> expr / expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    +               reduce using rule 21 (expr -> expr / expr .)
    -               reduce using rule 21 (expr -> expr / expr .)
    *               reduce using rule 21 (expr -> expr / expr .)
    /               reduce using rule 21 (expr -> expr / expr .)
    ASSIGN_ADD      reduce using rule 21 (expr -> expr / expr .)
    ASSIGN_SUB      reduce using rule 21 (expr -> expr / expr .)
    ASSIGN_MULT     reduce using rule 21 (expr -> expr / expr .)
    ASSIGN_DIV      reduce using rule 21 (expr -> expr / expr .)
    COMP_EQU        reduce using rule 21 (expr -> expr / expr .)
    COMP_NEQU       reduce using rule 21 (expr -> expr / expr .)
    <               reduce using rule 21 (expr -> expr / expr .)
    COMP_LTE        reduce using rule 21 (expr -> expr / expr .)
    >               reduce using rule 21 (expr -> expr / expr .)
    COMP_GTE        reduce using rule 21 (expr -> expr / expr .)
    BOOL_AND        reduce using rule 21 (expr -> expr / expr .)
    BOOL_OR         reduce using rule 21 (expr -> expr / expr .)
    ;               reduce using rule 21 (expr -> expr / expr .)
    )               reduce using rule 21 (expr -> expr / expr .)
    ,               reduce using rule 21 (expr -> expr / expr .)

  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 27 ]
  ! /               [ shift and go to state 28 ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! COMP_EQU        [ shift and go to state 42 ]
  ! COMP_NEQU       [ shift and go to state 41 ]
  ! <               [ shift and go to state 34 ]
  ! COMP_LTE        [ shift and go to state 35 ]
  ! >               [ shift and go to state 38 ]
  ! COMP_GTE        [ shift and go to state 30 ]
  ! BOOL_AND        [ shift and go to state 29 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 59

    (33) expr -> expr BOOL_AND expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    ASSIGN_ADD      reduce using rule 33 (expr -> expr BOOL_AND expr .)
    ASSIGN_SUB      reduce using rule 33 (expr -> expr BOOL_AND expr .)
    ASSIGN_MULT     reduce using rule 33 (expr -> expr BOOL_AND expr .)
    ASSIGN_DIV      reduce using rule 33 (expr -> expr BOOL_AND expr .)
    BOOL_AND        reduce using rule 33 (expr -> expr BOOL_AND expr .)
    BOOL_OR         reduce using rule 33 (expr -> expr BOOL_AND expr .)
    ;               reduce using rule 33 (expr -> expr BOOL_AND expr .)
    )               reduce using rule 33 (expr -> expr BOOL_AND expr .)
    ,               reduce using rule 33 (expr -> expr BOOL_AND expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30

  ! +               [ reduce using rule 33 (expr -> expr BOOL_AND expr .) ]
  ! -               [ reduce using rule 33 (expr -> expr BOOL_AND expr .) ]
  ! *               [ reduce using rule 33 (expr -> expr BOOL_AND expr .) ]
  ! /               [ reduce using rule 33 (expr -> expr BOOL_AND expr .) ]
  ! COMP_EQU        [ reduce using rule 33 (expr -> expr BOOL_AND expr .) ]
  ! COMP_NEQU       [ reduce using rule 33 (expr -> expr BOOL_AND expr .) ]
  ! <               [ reduce using rule 33 (expr -> expr BOOL_AND expr .) ]
  ! COMP_LTE        [ reduce using rule 33 (expr -> expr BOOL_AND expr .) ]
  ! >               [ reduce using rule 33 (expr -> expr BOOL_AND expr .) ]
  ! COMP_GTE        [ reduce using rule 33 (expr -> expr BOOL_AND expr .) ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! BOOL_AND        [ shift and go to state 29 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 60

    (32) expr -> expr COMP_GTE expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    ASSIGN_ADD      reduce using rule 32 (expr -> expr COMP_GTE expr .)
    ASSIGN_SUB      reduce using rule 32 (expr -> expr COMP_GTE expr .)
    ASSIGN_MULT     reduce using rule 32 (expr -> expr COMP_GTE expr .)
    ASSIGN_DIV      reduce using rule 32 (expr -> expr COMP_GTE expr .)
    COMP_EQU        reduce using rule 32 (expr -> expr COMP_GTE expr .)
    COMP_NEQU       reduce using rule 32 (expr -> expr COMP_GTE expr .)
    <               reduce using rule 32 (expr -> expr COMP_GTE expr .)
    COMP_LTE        reduce using rule 32 (expr -> expr COMP_GTE expr .)
    >               reduce using rule 32 (expr -> expr COMP_GTE expr .)
    COMP_GTE        reduce using rule 32 (expr -> expr COMP_GTE expr .)
    BOOL_AND        reduce using rule 32 (expr -> expr COMP_GTE expr .)
    BOOL_OR         reduce using rule 32 (expr -> expr COMP_GTE expr .)
    ;               reduce using rule 32 (expr -> expr COMP_GTE expr .)
    )               reduce using rule 32 (expr -> expr COMP_GTE expr .)
    ,               reduce using rule 32 (expr -> expr COMP_GTE expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28

  ! +               [ reduce using rule 32 (expr -> expr COMP_GTE expr .) ]
  ! -               [ reduce using rule 32 (expr -> expr COMP_GTE expr .) ]
  ! *               [ reduce using rule 32 (expr -> expr COMP_GTE expr .) ]
  ! /               [ reduce using rule 32 (expr -> expr COMP_GTE expr .) ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! COMP_EQU        [ shift and go to state 42 ]
  ! COMP_NEQU       [ shift and go to state 41 ]
  ! <               [ shift and go to state 34 ]
  ! COMP_LTE        [ shift and go to state 35 ]
  ! >               [ shift and go to state 38 ]
  ! COMP_GTE        [ shift and go to state 30 ]
  ! BOOL_AND        [ shift and go to state 29 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 61

    (34) expr -> expr BOOL_OR expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    ASSIGN_ADD      reduce using rule 34 (expr -> expr BOOL_OR expr .)
    ASSIGN_SUB      reduce using rule 34 (expr -> expr BOOL_OR expr .)
    ASSIGN_MULT     reduce using rule 34 (expr -> expr BOOL_OR expr .)
    ASSIGN_DIV      reduce using rule 34 (expr -> expr BOOL_OR expr .)
    BOOL_OR         reduce using rule 34 (expr -> expr BOOL_OR expr .)
    ;               reduce using rule 34 (expr -> expr BOOL_OR expr .)
    )               reduce using rule 34 (expr -> expr BOOL_OR expr .)
    ,               reduce using rule 34 (expr -> expr BOOL_OR expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29

  ! +               [ reduce using rule 34 (expr -> expr BOOL_OR expr .) ]
  ! -               [ reduce using rule 34 (expr -> expr BOOL_OR expr .) ]
  ! *               [ reduce using rule 34 (expr -> expr BOOL_OR expr .) ]
  ! /               [ reduce using rule 34 (expr -> expr BOOL_OR expr .) ]
  ! COMP_EQU        [ reduce using rule 34 (expr -> expr BOOL_OR expr .) ]
  ! COMP_NEQU       [ reduce using rule 34 (expr -> expr BOOL_OR expr .) ]
  ! <               [ reduce using rule 34 (expr -> expr BOOL_OR expr .) ]
  ! COMP_LTE        [ reduce using rule 34 (expr -> expr BOOL_OR expr .) ]
  ! >               [ reduce using rule 34 (expr -> expr BOOL_OR expr .) ]
  ! COMP_GTE        [ reduce using rule 34 (expr -> expr BOOL_OR expr .) ]
  ! BOOL_AND        [ reduce using rule 34 (expr -> expr BOOL_OR expr .) ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 62

    (19) expr -> expr - expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    +               reduce using rule 19 (expr -> expr - expr .)
    -               reduce using rule 19 (expr -> expr - expr .)
    ASSIGN_ADD      reduce using rule 19 (expr -> expr - expr .)
    ASSIGN_SUB      reduce using rule 19 (expr -> expr - expr .)
    ASSIGN_MULT     reduce using rule 19 (expr -> expr - expr .)
    ASSIGN_DIV      reduce using rule 19 (expr -> expr - expr .)
    COMP_EQU        reduce using rule 19 (expr -> expr - expr .)
    COMP_NEQU       reduce using rule 19 (expr -> expr - expr .)
    <               reduce using rule 19 (expr -> expr - expr .)
    COMP_LTE        reduce using rule 19 (expr -> expr - expr .)
    >               reduce using rule 19 (expr -> expr - expr .)
    COMP_GTE        reduce using rule 19 (expr -> expr - expr .)
    BOOL_AND        reduce using rule 19 (expr -> expr - expr .)
    BOOL_OR         reduce using rule 19 (expr -> expr - expr .)
    ;               reduce using rule 19 (expr -> expr - expr .)
    )               reduce using rule 19 (expr -> expr - expr .)
    ,               reduce using rule 19 (expr -> expr - expr .)
    *               shift and go to state 27
    /               shift and go to state 28

  ! *               [ reduce using rule 19 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 19 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 33 ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! COMP_EQU        [ shift and go to state 42 ]
  ! COMP_NEQU       [ shift and go to state 41 ]
  ! <               [ shift and go to state 34 ]
  ! COMP_LTE        [ shift and go to state 35 ]
  ! >               [ shift and go to state 38 ]
  ! COMP_GTE        [ shift and go to state 30 ]
  ! BOOL_AND        [ shift and go to state 29 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 63

    (29) expr -> expr < expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    ASSIGN_ADD      reduce using rule 29 (expr -> expr < expr .)
    ASSIGN_SUB      reduce using rule 29 (expr -> expr < expr .)
    ASSIGN_MULT     reduce using rule 29 (expr -> expr < expr .)
    ASSIGN_DIV      reduce using rule 29 (expr -> expr < expr .)
    COMP_EQU        reduce using rule 29 (expr -> expr < expr .)
    COMP_NEQU       reduce using rule 29 (expr -> expr < expr .)
    <               reduce using rule 29 (expr -> expr < expr .)
    COMP_LTE        reduce using rule 29 (expr -> expr < expr .)
    >               reduce using rule 29 (expr -> expr < expr .)
    COMP_GTE        reduce using rule 29 (expr -> expr < expr .)
    BOOL_AND        reduce using rule 29 (expr -> expr < expr .)
    BOOL_OR         reduce using rule 29 (expr -> expr < expr .)
    ;               reduce using rule 29 (expr -> expr < expr .)
    )               reduce using rule 29 (expr -> expr < expr .)
    ,               reduce using rule 29 (expr -> expr < expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28

  ! +               [ reduce using rule 29 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 29 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 29 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 29 (expr -> expr < expr .) ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! COMP_EQU        [ shift and go to state 42 ]
  ! COMP_NEQU       [ shift and go to state 41 ]
  ! <               [ shift and go to state 34 ]
  ! COMP_LTE        [ shift and go to state 35 ]
  ! >               [ shift and go to state 38 ]
  ! COMP_GTE        [ shift and go to state 30 ]
  ! BOOL_AND        [ shift and go to state 29 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 64

    (30) expr -> expr COMP_LTE expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    ASSIGN_ADD      reduce using rule 30 (expr -> expr COMP_LTE expr .)
    ASSIGN_SUB      reduce using rule 30 (expr -> expr COMP_LTE expr .)
    ASSIGN_MULT     reduce using rule 30 (expr -> expr COMP_LTE expr .)
    ASSIGN_DIV      reduce using rule 30 (expr -> expr COMP_LTE expr .)
    COMP_EQU        reduce using rule 30 (expr -> expr COMP_LTE expr .)
    COMP_NEQU       reduce using rule 30 (expr -> expr COMP_LTE expr .)
    <               reduce using rule 30 (expr -> expr COMP_LTE expr .)
    COMP_LTE        reduce using rule 30 (expr -> expr COMP_LTE expr .)
    >               reduce using rule 30 (expr -> expr COMP_LTE expr .)
    COMP_GTE        reduce using rule 30 (expr -> expr COMP_LTE expr .)
    BOOL_AND        reduce using rule 30 (expr -> expr COMP_LTE expr .)
    BOOL_OR         reduce using rule 30 (expr -> expr COMP_LTE expr .)
    ;               reduce using rule 30 (expr -> expr COMP_LTE expr .)
    )               reduce using rule 30 (expr -> expr COMP_LTE expr .)
    ,               reduce using rule 30 (expr -> expr COMP_LTE expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28

  ! +               [ reduce using rule 30 (expr -> expr COMP_LTE expr .) ]
  ! -               [ reduce using rule 30 (expr -> expr COMP_LTE expr .) ]
  ! *               [ reduce using rule 30 (expr -> expr COMP_LTE expr .) ]
  ! /               [ reduce using rule 30 (expr -> expr COMP_LTE expr .) ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! COMP_EQU        [ shift and go to state 42 ]
  ! COMP_NEQU       [ shift and go to state 41 ]
  ! <               [ shift and go to state 34 ]
  ! COMP_LTE        [ shift and go to state 35 ]
  ! >               [ shift and go to state 38 ]
  ! COMP_GTE        [ shift and go to state 30 ]
  ! BOOL_AND        [ shift and go to state 29 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 65

    (18) expr -> expr + expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    +               reduce using rule 18 (expr -> expr + expr .)
    -               reduce using rule 18 (expr -> expr + expr .)
    ASSIGN_ADD      reduce using rule 18 (expr -> expr + expr .)
    ASSIGN_SUB      reduce using rule 18 (expr -> expr + expr .)
    ASSIGN_MULT     reduce using rule 18 (expr -> expr + expr .)
    ASSIGN_DIV      reduce using rule 18 (expr -> expr + expr .)
    COMP_EQU        reduce using rule 18 (expr -> expr + expr .)
    COMP_NEQU       reduce using rule 18 (expr -> expr + expr .)
    <               reduce using rule 18 (expr -> expr + expr .)
    COMP_LTE        reduce using rule 18 (expr -> expr + expr .)
    >               reduce using rule 18 (expr -> expr + expr .)
    COMP_GTE        reduce using rule 18 (expr -> expr + expr .)
    BOOL_AND        reduce using rule 18 (expr -> expr + expr .)
    BOOL_OR         reduce using rule 18 (expr -> expr + expr .)
    ;               reduce using rule 18 (expr -> expr + expr .)
    )               reduce using rule 18 (expr -> expr + expr .)
    ,               reduce using rule 18 (expr -> expr + expr .)
    *               shift and go to state 27
    /               shift and go to state 28

  ! *               [ reduce using rule 18 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 18 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 33 ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! COMP_EQU        [ shift and go to state 42 ]
  ! COMP_NEQU       [ shift and go to state 41 ]
  ! <               [ shift and go to state 34 ]
  ! COMP_LTE        [ shift and go to state 35 ]
  ! >               [ shift and go to state 38 ]
  ! COMP_GTE        [ shift and go to state 30 ]
  ! BOOL_AND        [ shift and go to state 29 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 66

    (24) expr -> expr ASSIGN_MULT expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ASSIGN_ADD resolved as shift
  ! shift/reduce conflict for ASSIGN_SUB resolved as shift
  ! shift/reduce conflict for ASSIGN_MULT resolved as shift
  ! shift/reduce conflict for ASSIGN_DIV resolved as shift
  ! shift/reduce conflict for COMP_EQU resolved as shift
  ! shift/reduce conflict for COMP_NEQU resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for COMP_LTE resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for COMP_GTE resolved as shift
  ! shift/reduce conflict for BOOL_AND resolved as shift
  ! shift/reduce conflict for BOOL_OR resolved as shift
    ;               reduce using rule 24 (expr -> expr ASSIGN_MULT expr .)
    )               reduce using rule 24 (expr -> expr ASSIGN_MULT expr .)
    ,               reduce using rule 24 (expr -> expr ASSIGN_MULT expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    ASSIGN_ADD      shift and go to state 40
    ASSIGN_SUB      shift and go to state 39
    ASSIGN_MULT     shift and go to state 37
    ASSIGN_DIV      shift and go to state 26
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32

  ! +               [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! -               [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! *               [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! /               [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! ASSIGN_ADD      [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! ASSIGN_SUB      [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! ASSIGN_MULT     [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! ASSIGN_DIV      [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! COMP_EQU        [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! COMP_NEQU       [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! <               [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! COMP_LTE        [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! >               [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! COMP_GTE        [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! BOOL_AND        [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]
  ! BOOL_OR         [ reduce using rule 24 (expr -> expr ASSIGN_MULT expr .) ]


state 67

    (31) expr -> expr > expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    ASSIGN_ADD      reduce using rule 31 (expr -> expr > expr .)
    ASSIGN_SUB      reduce using rule 31 (expr -> expr > expr .)
    ASSIGN_MULT     reduce using rule 31 (expr -> expr > expr .)
    ASSIGN_DIV      reduce using rule 31 (expr -> expr > expr .)
    COMP_EQU        reduce using rule 31 (expr -> expr > expr .)
    COMP_NEQU       reduce using rule 31 (expr -> expr > expr .)
    <               reduce using rule 31 (expr -> expr > expr .)
    COMP_LTE        reduce using rule 31 (expr -> expr > expr .)
    >               reduce using rule 31 (expr -> expr > expr .)
    COMP_GTE        reduce using rule 31 (expr -> expr > expr .)
    BOOL_AND        reduce using rule 31 (expr -> expr > expr .)
    BOOL_OR         reduce using rule 31 (expr -> expr > expr .)
    ;               reduce using rule 31 (expr -> expr > expr .)
    )               reduce using rule 31 (expr -> expr > expr .)
    ,               reduce using rule 31 (expr -> expr > expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28

  ! +               [ reduce using rule 31 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 31 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 31 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 31 (expr -> expr > expr .) ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! COMP_EQU        [ shift and go to state 42 ]
  ! COMP_NEQU       [ shift and go to state 41 ]
  ! <               [ shift and go to state 34 ]
  ! COMP_LTE        [ shift and go to state 35 ]
  ! >               [ shift and go to state 38 ]
  ! COMP_GTE        [ shift and go to state 30 ]
  ! BOOL_AND        [ shift and go to state 29 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 68

    (23) expr -> expr ASSIGN_SUB expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ASSIGN_ADD resolved as shift
  ! shift/reduce conflict for ASSIGN_SUB resolved as shift
  ! shift/reduce conflict for ASSIGN_MULT resolved as shift
  ! shift/reduce conflict for ASSIGN_DIV resolved as shift
  ! shift/reduce conflict for COMP_EQU resolved as shift
  ! shift/reduce conflict for COMP_NEQU resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for COMP_LTE resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for COMP_GTE resolved as shift
  ! shift/reduce conflict for BOOL_AND resolved as shift
  ! shift/reduce conflict for BOOL_OR resolved as shift
    ;               reduce using rule 23 (expr -> expr ASSIGN_SUB expr .)
    )               reduce using rule 23 (expr -> expr ASSIGN_SUB expr .)
    ,               reduce using rule 23 (expr -> expr ASSIGN_SUB expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    ASSIGN_ADD      shift and go to state 40
    ASSIGN_SUB      shift and go to state 39
    ASSIGN_MULT     shift and go to state 37
    ASSIGN_DIV      shift and go to state 26
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32

  ! +               [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! -               [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! *               [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! /               [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! ASSIGN_ADD      [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! ASSIGN_SUB      [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! ASSIGN_MULT     [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! ASSIGN_DIV      [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! COMP_EQU        [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! COMP_NEQU       [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! <               [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! COMP_LTE        [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! >               [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! COMP_GTE        [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! BOOL_AND        [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]
  ! BOOL_OR         [ reduce using rule 23 (expr -> expr ASSIGN_SUB expr .) ]


state 69

    (22) expr -> expr ASSIGN_ADD expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ASSIGN_ADD resolved as shift
  ! shift/reduce conflict for ASSIGN_SUB resolved as shift
  ! shift/reduce conflict for ASSIGN_MULT resolved as shift
  ! shift/reduce conflict for ASSIGN_DIV resolved as shift
  ! shift/reduce conflict for COMP_EQU resolved as shift
  ! shift/reduce conflict for COMP_NEQU resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for COMP_LTE resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for COMP_GTE resolved as shift
  ! shift/reduce conflict for BOOL_AND resolved as shift
  ! shift/reduce conflict for BOOL_OR resolved as shift
    ;               reduce using rule 22 (expr -> expr ASSIGN_ADD expr .)
    )               reduce using rule 22 (expr -> expr ASSIGN_ADD expr .)
    ,               reduce using rule 22 (expr -> expr ASSIGN_ADD expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    ASSIGN_ADD      shift and go to state 40
    ASSIGN_SUB      shift and go to state 39
    ASSIGN_MULT     shift and go to state 37
    ASSIGN_DIV      shift and go to state 26
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32

  ! +               [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! -               [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! *               [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! /               [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! ASSIGN_ADD      [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! ASSIGN_SUB      [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! ASSIGN_MULT     [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! ASSIGN_DIV      [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! COMP_EQU        [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! COMP_NEQU       [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! <               [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! COMP_LTE        [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! >               [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! COMP_GTE        [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! BOOL_AND        [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]
  ! BOOL_OR         [ reduce using rule 22 (expr -> expr ASSIGN_ADD expr .) ]


state 70

    (28) expr -> expr COMP_NEQU expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    ASSIGN_ADD      reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    ASSIGN_SUB      reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    ASSIGN_MULT     reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    ASSIGN_DIV      reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    COMP_EQU        reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    COMP_NEQU       reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    <               reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    COMP_LTE        reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    >               reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    COMP_GTE        reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    BOOL_AND        reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    BOOL_OR         reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    ;               reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    )               reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    ,               reduce using rule 28 (expr -> expr COMP_NEQU expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28

  ! +               [ reduce using rule 28 (expr -> expr COMP_NEQU expr .) ]
  ! -               [ reduce using rule 28 (expr -> expr COMP_NEQU expr .) ]
  ! *               [ reduce using rule 28 (expr -> expr COMP_NEQU expr .) ]
  ! /               [ reduce using rule 28 (expr -> expr COMP_NEQU expr .) ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! COMP_EQU        [ shift and go to state 42 ]
  ! COMP_NEQU       [ shift and go to state 41 ]
  ! <               [ shift and go to state 34 ]
  ! COMP_LTE        [ shift and go to state 35 ]
  ! >               [ shift and go to state 38 ]
  ! COMP_GTE        [ shift and go to state 30 ]
  ! BOOL_AND        [ shift and go to state 29 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 71

    (27) expr -> expr COMP_EQU expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    ASSIGN_ADD      reduce using rule 27 (expr -> expr COMP_EQU expr .)
    ASSIGN_SUB      reduce using rule 27 (expr -> expr COMP_EQU expr .)
    ASSIGN_MULT     reduce using rule 27 (expr -> expr COMP_EQU expr .)
    ASSIGN_DIV      reduce using rule 27 (expr -> expr COMP_EQU expr .)
    COMP_EQU        reduce using rule 27 (expr -> expr COMP_EQU expr .)
    COMP_NEQU       reduce using rule 27 (expr -> expr COMP_EQU expr .)
    <               reduce using rule 27 (expr -> expr COMP_EQU expr .)
    COMP_LTE        reduce using rule 27 (expr -> expr COMP_EQU expr .)
    >               reduce using rule 27 (expr -> expr COMP_EQU expr .)
    COMP_GTE        reduce using rule 27 (expr -> expr COMP_EQU expr .)
    BOOL_AND        reduce using rule 27 (expr -> expr COMP_EQU expr .)
    BOOL_OR         reduce using rule 27 (expr -> expr COMP_EQU expr .)
    ;               reduce using rule 27 (expr -> expr COMP_EQU expr .)
    )               reduce using rule 27 (expr -> expr COMP_EQU expr .)
    ,               reduce using rule 27 (expr -> expr COMP_EQU expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28

  ! +               [ reduce using rule 27 (expr -> expr COMP_EQU expr .) ]
  ! -               [ reduce using rule 27 (expr -> expr COMP_EQU expr .) ]
  ! *               [ reduce using rule 27 (expr -> expr COMP_EQU expr .) ]
  ! /               [ reduce using rule 27 (expr -> expr COMP_EQU expr .) ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]
  ! COMP_EQU        [ shift and go to state 42 ]
  ! COMP_NEQU       [ shift and go to state 41 ]
  ! <               [ shift and go to state 34 ]
  ! COMP_LTE        [ shift and go to state 35 ]
  ! >               [ shift and go to state 38 ]
  ! COMP_GTE        [ shift and go to state 30 ]
  ! BOOL_AND        [ shift and go to state 29 ]
  ! BOOL_OR         [ shift and go to state 32 ]


state 72

    (37) arguments -> expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    )               reduce using rule 37 (arguments -> expr .)
    ,               reduce using rule 37 (arguments -> expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    ASSIGN_ADD      shift and go to state 40
    ASSIGN_SUB      shift and go to state 39
    ASSIGN_MULT     shift and go to state 37
    ASSIGN_DIV      shift and go to state 26
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32


state 73

    (36) expr -> COMMAND_PRINT ( arguments . )
    (38) arguments -> arguments . , expr

    )               shift and go to state 82
    ,               shift and go to state 81


state 74

    (45) expr -> variable = expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    ASSIGN_ADD      reduce using rule 45 (expr -> variable = expr .)
    ASSIGN_SUB      reduce using rule 45 (expr -> variable = expr .)
    ASSIGN_MULT     reduce using rule 45 (expr -> variable = expr .)
    ASSIGN_DIV      reduce using rule 45 (expr -> variable = expr .)
    ;               reduce using rule 45 (expr -> variable = expr .)
    )               reduce using rule 45 (expr -> variable = expr .)
    ,               reduce using rule 45 (expr -> variable = expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32

  ! +               [ reduce using rule 45 (expr -> variable = expr .) ]
  ! -               [ reduce using rule 45 (expr -> variable = expr .) ]
  ! *               [ reduce using rule 45 (expr -> variable = expr .) ]
  ! /               [ reduce using rule 45 (expr -> variable = expr .) ]
  ! COMP_EQU        [ reduce using rule 45 (expr -> variable = expr .) ]
  ! COMP_NEQU       [ reduce using rule 45 (expr -> variable = expr .) ]
  ! <               [ reduce using rule 45 (expr -> variable = expr .) ]
  ! COMP_LTE        [ reduce using rule 45 (expr -> variable = expr .) ]
  ! >               [ reduce using rule 45 (expr -> variable = expr .) ]
  ! COMP_GTE        [ reduce using rule 45 (expr -> variable = expr .) ]
  ! BOOL_AND        [ reduce using rule 45 (expr -> variable = expr .) ]
  ! BOOL_OR         [ reduce using rule 45 (expr -> variable = expr .) ]
  ! ASSIGN_ADD      [ shift and go to state 40 ]
  ! ASSIGN_SUB      [ shift and go to state 39 ]
  ! ASSIGN_MULT     [ shift and go to state 37 ]
  ! ASSIGN_DIV      [ shift and go to state 26 ]


state 75

    (12) if_block -> COMMAND_IF ( expr . ) statement
    (13) if_block -> COMMAND_IF ( expr . ) statement COMMAND_ELSE statement
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    )               shift and go to state 83
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    ASSIGN_ADD      shift and go to state 40
    ASSIGN_SUB      shift and go to state 39
    ASSIGN_MULT     shift and go to state 37
    ASSIGN_DIV      shift and go to state 26
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32


state 76

    (11) block -> OPEN_BLOCK statements CLOSE_BLOCK .

    CLOSE_BLOCK     reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    ;               reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    (               reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    !               reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    COMMAND_PRINT   reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    COMMAND_RANDOM  reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    VAL_LITERAL     reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    -               reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    CHAR_LITERAL    reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    TYPE            reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    OPEN_BLOCK      reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    COMMAND_IF      reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    COMMAND_WHILE   reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    COMMAND_BREAK   reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    ID              reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    COMMAND_ELSE    reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)
    $end            reduce using rule 11 (block -> OPEN_BLOCK statements CLOSE_BLOCK .)


state 77

    (39) expr -> COMMAND_RANDOM ( expr . )
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    )               shift and go to state 84
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    ASSIGN_ADD      shift and go to state 40
    ASSIGN_SUB      shift and go to state 39
    ASSIGN_MULT     shift and go to state 37
    ASSIGN_DIV      shift and go to state 26
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32


state 78

    (26) expr -> ( expr ) .

    +               reduce using rule 26 (expr -> ( expr ) .)
    -               reduce using rule 26 (expr -> ( expr ) .)
    *               reduce using rule 26 (expr -> ( expr ) .)
    /               reduce using rule 26 (expr -> ( expr ) .)
    ASSIGN_ADD      reduce using rule 26 (expr -> ( expr ) .)
    ASSIGN_SUB      reduce using rule 26 (expr -> ( expr ) .)
    ASSIGN_MULT     reduce using rule 26 (expr -> ( expr ) .)
    ASSIGN_DIV      reduce using rule 26 (expr -> ( expr ) .)
    COMP_EQU        reduce using rule 26 (expr -> ( expr ) .)
    COMP_NEQU       reduce using rule 26 (expr -> ( expr ) .)
    <               reduce using rule 26 (expr -> ( expr ) .)
    COMP_LTE        reduce using rule 26 (expr -> ( expr ) .)
    >               reduce using rule 26 (expr -> ( expr ) .)
    COMP_GTE        reduce using rule 26 (expr -> ( expr ) .)
    BOOL_AND        reduce using rule 26 (expr -> ( expr ) .)
    BOOL_OR         reduce using rule 26 (expr -> ( expr ) .)
    ;               reduce using rule 26 (expr -> ( expr ) .)
    )               reduce using rule 26 (expr -> ( expr ) .)
    ,               reduce using rule 26 (expr -> ( expr ) .)


state 79

    (15) while_loop -> COMMAND_WHILE ( expr . ) statement
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    )               shift and go to state 85
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    ASSIGN_ADD      shift and go to state 40
    ASSIGN_SUB      shift and go to state 39
    ASSIGN_MULT     shift and go to state 37
    ASSIGN_DIV      shift and go to state 26
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32


state 80

    (17) declaration -> TYPE ID = expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    ;               reduce using rule 17 (declaration -> TYPE ID = expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    ASSIGN_ADD      shift and go to state 40
    ASSIGN_SUB      shift and go to state 39
    ASSIGN_MULT     shift and go to state 37
    ASSIGN_DIV      shift and go to state 26
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32


state 81

    (38) arguments -> arguments , . expr
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (46) variable -> . ID

    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    ID              shift and go to state 6

    variable                       shift and go to state 11
    expr                           shift and go to state 86

state 82

    (36) expr -> COMMAND_PRINT ( arguments ) .

    +               reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    -               reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    *               reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    /               reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    ASSIGN_ADD      reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    ASSIGN_SUB      reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    ASSIGN_MULT     reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    ASSIGN_DIV      reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    COMP_EQU        reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    COMP_NEQU       reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    <               reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    COMP_LTE        reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    >               reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    COMP_GTE        reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    BOOL_AND        reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    BOOL_OR         reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    ;               reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    )               reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)
    ,               reduce using rule 36 (expr -> COMMAND_PRINT ( arguments ) .)


state 83

    (12) if_block -> COMMAND_IF ( expr ) . statement
    (13) if_block -> COMMAND_IF ( expr ) . statement COMMAND_ELSE statement
    (4) statement -> . expr ;
    (5) statement -> . declaration ;
    (6) statement -> . block
    (7) statement -> . if_block
    (8) statement -> . while_loop
    (9) statement -> . break ;
    (10) statement -> . ;
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (16) declaration -> . TYPE ID
    (17) declaration -> . TYPE ID = expr
    (11) block -> . OPEN_BLOCK statements CLOSE_BLOCK
    (12) if_block -> . COMMAND_IF ( expr ) statement
    (13) if_block -> . COMMAND_IF ( expr ) statement COMMAND_ELSE statement
    (15) while_loop -> . COMMAND_WHILE ( expr ) statement
    (14) break -> . COMMAND_BREAK
    (46) variable -> . ID

    ;               shift and go to state 7
    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    TYPE            shift and go to state 5
    OPEN_BLOCK      shift and go to state 15
    COMMAND_IF      shift and go to state 12
    COMMAND_WHILE   shift and go to state 22
    COMMAND_BREAK   shift and go to state 3
    ID              shift and go to state 6

    break                          shift and go to state 9
    block                          shift and go to state 4
    while_loop                     shift and go to state 23
    if_block                       shift and go to state 13
    declaration                    shift and go to state 18
    variable                       shift and go to state 11
    expr                           shift and go to state 8
    statement                      shift and go to state 87

state 84

    (39) expr -> COMMAND_RANDOM ( expr ) .

    +               reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    -               reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    *               reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    /               reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    ASSIGN_ADD      reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    ASSIGN_SUB      reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    ASSIGN_MULT     reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    ASSIGN_DIV      reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    COMP_EQU        reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    COMP_NEQU       reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    <               reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    COMP_LTE        reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    >               reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    COMP_GTE        reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    BOOL_AND        reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    BOOL_OR         reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    ;               reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    )               reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)
    ,               reduce using rule 39 (expr -> COMMAND_RANDOM ( expr ) .)


state 85

    (15) while_loop -> COMMAND_WHILE ( expr ) . statement
    (4) statement -> . expr ;
    (5) statement -> . declaration ;
    (6) statement -> . block
    (7) statement -> . if_block
    (8) statement -> . while_loop
    (9) statement -> . break ;
    (10) statement -> . ;
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (16) declaration -> . TYPE ID
    (17) declaration -> . TYPE ID = expr
    (11) block -> . OPEN_BLOCK statements CLOSE_BLOCK
    (12) if_block -> . COMMAND_IF ( expr ) statement
    (13) if_block -> . COMMAND_IF ( expr ) statement COMMAND_ELSE statement
    (15) while_loop -> . COMMAND_WHILE ( expr ) statement
    (14) break -> . COMMAND_BREAK
    (46) variable -> . ID

    ;               shift and go to state 7
    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    TYPE            shift and go to state 5
    OPEN_BLOCK      shift and go to state 15
    COMMAND_IF      shift and go to state 12
    COMMAND_WHILE   shift and go to state 22
    COMMAND_BREAK   shift and go to state 3
    ID              shift and go to state 6

    break                          shift and go to state 9
    block                          shift and go to state 4
    while_loop                     shift and go to state 23
    if_block                       shift and go to state 13
    declaration                    shift and go to state 18
    variable                       shift and go to state 11
    expr                           shift and go to state 8
    statement                      shift and go to state 88

state 86

    (38) arguments -> arguments , expr .
    (18) expr -> expr . + expr
    (19) expr -> expr . - expr
    (20) expr -> expr . * expr
    (21) expr -> expr . / expr
    (22) expr -> expr . ASSIGN_ADD expr
    (23) expr -> expr . ASSIGN_SUB expr
    (24) expr -> expr . ASSIGN_MULT expr
    (25) expr -> expr . ASSIGN_DIV expr
    (27) expr -> expr . COMP_EQU expr
    (28) expr -> expr . COMP_NEQU expr
    (29) expr -> expr . < expr
    (30) expr -> expr . COMP_LTE expr
    (31) expr -> expr . > expr
    (32) expr -> expr . COMP_GTE expr
    (33) expr -> expr . BOOL_AND expr
    (34) expr -> expr . BOOL_OR expr

    )               reduce using rule 38 (arguments -> arguments , expr .)
    ,               reduce using rule 38 (arguments -> arguments , expr .)
    +               shift and go to state 36
    -               shift and go to state 33
    *               shift and go to state 27
    /               shift and go to state 28
    ASSIGN_ADD      shift and go to state 40
    ASSIGN_SUB      shift and go to state 39
    ASSIGN_MULT     shift and go to state 37
    ASSIGN_DIV      shift and go to state 26
    COMP_EQU        shift and go to state 42
    COMP_NEQU       shift and go to state 41
    <               shift and go to state 34
    COMP_LTE        shift and go to state 35
    >               shift and go to state 38
    COMP_GTE        shift and go to state 30
    BOOL_AND        shift and go to state 29
    BOOL_OR         shift and go to state 32


state 87

    (12) if_block -> COMMAND_IF ( expr ) statement .
    (13) if_block -> COMMAND_IF ( expr ) statement . COMMAND_ELSE statement

  ! shift/reduce conflict for COMMAND_ELSE resolved as shift
    CLOSE_BLOCK     reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    ;               reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    (               reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    !               reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    COMMAND_PRINT   reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    COMMAND_RANDOM  reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    VAL_LITERAL     reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    -               reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    CHAR_LITERAL    reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    TYPE            reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    OPEN_BLOCK      reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    COMMAND_IF      reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    COMMAND_WHILE   reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    COMMAND_BREAK   reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    ID              reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    $end            reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .)
    COMMAND_ELSE    shift and go to state 89

  ! COMMAND_ELSE    [ reduce using rule 12 (if_block -> COMMAND_IF ( expr ) statement .) ]


state 88

    (15) while_loop -> COMMAND_WHILE ( expr ) statement .

    COMMAND_ELSE    reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    ;               reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    (               reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    !               reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    COMMAND_PRINT   reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    COMMAND_RANDOM  reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    VAL_LITERAL     reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    -               reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    CHAR_LITERAL    reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    TYPE            reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    OPEN_BLOCK      reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    COMMAND_IF      reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    COMMAND_WHILE   reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    COMMAND_BREAK   reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    ID              reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    $end            reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)
    CLOSE_BLOCK     reduce using rule 15 (while_loop -> COMMAND_WHILE ( expr ) statement .)


state 89

    (13) if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE . statement
    (4) statement -> . expr ;
    (5) statement -> . declaration ;
    (6) statement -> . block
    (7) statement -> . if_block
    (8) statement -> . while_loop
    (9) statement -> . break ;
    (10) statement -> . ;
    (18) expr -> . expr + expr
    (19) expr -> . expr - expr
    (20) expr -> . expr * expr
    (21) expr -> . expr / expr
    (22) expr -> . expr ASSIGN_ADD expr
    (23) expr -> . expr ASSIGN_SUB expr
    (24) expr -> . expr ASSIGN_MULT expr
    (25) expr -> . expr ASSIGN_DIV expr
    (26) expr -> . ( expr )
    (27) expr -> . expr COMP_EQU expr
    (28) expr -> . expr COMP_NEQU expr
    (29) expr -> . expr < expr
    (30) expr -> . expr COMP_LTE expr
    (31) expr -> . expr > expr
    (32) expr -> . expr COMP_GTE expr
    (33) expr -> . expr BOOL_AND expr
    (34) expr -> . expr BOOL_OR expr
    (35) expr -> . ! expr
    (36) expr -> . COMMAND_PRINT ( arguments )
    (39) expr -> . COMMAND_RANDOM ( expr )
    (40) expr -> . VAL_LITERAL
    (41) expr -> . - VAL_LITERAL
    (42) expr -> . CHAR_LITERAL
    (43) expr -> . variable
    (44) expr -> . - variable
    (45) expr -> . variable = expr
    (16) declaration -> . TYPE ID
    (17) declaration -> . TYPE ID = expr
    (11) block -> . OPEN_BLOCK statements CLOSE_BLOCK
    (12) if_block -> . COMMAND_IF ( expr ) statement
    (13) if_block -> . COMMAND_IF ( expr ) statement COMMAND_ELSE statement
    (15) while_loop -> . COMMAND_WHILE ( expr ) statement
    (14) break -> . COMMAND_BREAK
    (46) variable -> . ID

    ;               shift and go to state 7
    (               shift and go to state 20
    !               shift and go to state 19
    COMMAND_PRINT   shift and go to state 10
    COMMAND_RANDOM  shift and go to state 17
    VAL_LITERAL     shift and go to state 21
    -               shift and go to state 14
    CHAR_LITERAL    shift and go to state 24
    TYPE            shift and go to state 5
    OPEN_BLOCK      shift and go to state 15
    COMMAND_IF      shift and go to state 12
    COMMAND_WHILE   shift and go to state 22
    COMMAND_BREAK   shift and go to state 3
    ID              shift and go to state 6

    break                          shift and go to state 9
    block                          shift and go to state 4
    while_loop                     shift and go to state 23
    if_block                       shift and go to state 13
    declaration                    shift and go to state 18
    variable                       shift and go to state 11
    expr                           shift and go to state 8
    statement                      shift and go to state 90

state 90

    (13) if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .

    CLOSE_BLOCK     reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    ;               reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    (               reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    !               reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    COMMAND_PRINT   reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    COMMAND_RANDOM  reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    VAL_LITERAL     reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    -               reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    CHAR_LITERAL    reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    TYPE            reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    OPEN_BLOCK      reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    COMMAND_IF      reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    COMMAND_WHILE   reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    COMMAND_BREAK   reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    ID              reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    COMMAND_ELSE    reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)
    $end            reduce using rule 13 (if_block -> COMMAND_IF ( expr ) statement COMMAND_ELSE statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for + in state 56 resolved as shift
WARNING: shift/reduce conflict for - in state 56 resolved as shift
WARNING: shift/reduce conflict for * in state 56 resolved as shift
WARNING: shift/reduce conflict for / in state 56 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_ADD in state 56 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_SUB in state 56 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_MULT in state 56 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_DIV in state 56 resolved as shift
WARNING: shift/reduce conflict for COMP_EQU in state 56 resolved as shift
WARNING: shift/reduce conflict for COMP_NEQU in state 56 resolved as shift
WARNING: shift/reduce conflict for < in state 56 resolved as shift
WARNING: shift/reduce conflict for COMP_LTE in state 56 resolved as shift
WARNING: shift/reduce conflict for > in state 56 resolved as shift
WARNING: shift/reduce conflict for COMP_GTE in state 56 resolved as shift
WARNING: shift/reduce conflict for BOOL_AND in state 56 resolved as shift
WARNING: shift/reduce conflict for BOOL_OR in state 56 resolved as shift
WARNING: shift/reduce conflict for + in state 66 resolved as shift
WARNING: shift/reduce conflict for - in state 66 resolved as shift
WARNING: shift/reduce conflict for * in state 66 resolved as shift
WARNING: shift/reduce conflict for / in state 66 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_ADD in state 66 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_SUB in state 66 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_MULT in state 66 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_DIV in state 66 resolved as shift
WARNING: shift/reduce conflict for COMP_EQU in state 66 resolved as shift
WARNING: shift/reduce conflict for COMP_NEQU in state 66 resolved as shift
WARNING: shift/reduce conflict for < in state 66 resolved as shift
WARNING: shift/reduce conflict for COMP_LTE in state 66 resolved as shift
WARNING: shift/reduce conflict for > in state 66 resolved as shift
WARNING: shift/reduce conflict for COMP_GTE in state 66 resolved as shift
WARNING: shift/reduce conflict for BOOL_AND in state 66 resolved as shift
WARNING: shift/reduce conflict for BOOL_OR in state 66 resolved as shift
WARNING: shift/reduce conflict for + in state 68 resolved as shift
WARNING: shift/reduce conflict for - in state 68 resolved as shift
WARNING: shift/reduce conflict for * in state 68 resolved as shift
WARNING: shift/reduce conflict for / in state 68 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_ADD in state 68 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_SUB in state 68 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_MULT in state 68 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_DIV in state 68 resolved as shift
WARNING: shift/reduce conflict for COMP_EQU in state 68 resolved as shift
WARNING: shift/reduce conflict for COMP_NEQU in state 68 resolved as shift
WARNING: shift/reduce conflict for < in state 68 resolved as shift
WARNING: shift/reduce conflict for COMP_LTE in state 68 resolved as shift
WARNING: shift/reduce conflict for > in state 68 resolved as shift
WARNING: shift/reduce conflict for COMP_GTE in state 68 resolved as shift
WARNING: shift/reduce conflict for BOOL_AND in state 68 resolved as shift
WARNING: shift/reduce conflict for BOOL_OR in state 68 resolved as shift
WARNING: shift/reduce conflict for + in state 69 resolved as shift
WARNING: shift/reduce conflict for - in state 69 resolved as shift
WARNING: shift/reduce conflict for * in state 69 resolved as shift
WARNING: shift/reduce conflict for / in state 69 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_ADD in state 69 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_SUB in state 69 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_MULT in state 69 resolved as shift
WARNING: shift/reduce conflict for ASSIGN_DIV in state 69 resolved as shift
WARNING: shift/reduce conflict for COMP_EQU in state 69 resolved as shift
WARNING: shift/reduce conflict for COMP_NEQU in state 69 resolved as shift
WARNING: shift/reduce conflict for < in state 69 resolved as shift
WARNING: shift/reduce conflict for COMP_LTE in state 69 resolved as shift
WARNING: shift/reduce conflict for > in state 69 resolved as shift
WARNING: shift/reduce conflict for COMP_GTE in state 69 resolved as shift
WARNING: shift/reduce conflict for BOOL_AND in state 69 resolved as shift
WARNING: shift/reduce conflict for BOOL_OR in state 69 resolved as shift
WARNING: shift/reduce conflict for COMMAND_ELSE in state 87 resolved as shift
